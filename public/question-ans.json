[
    {
        "id":1,
        "question":"1. Tell us the differences between uncontrolled and controlled components.",
        "ans":"In React, controlled components refer to components that have their state and behavior controlled by the parent component. These components rely on props passed down from the parent component to update their state and behavior. Uncontrolled components refer to components that manage their own state internally.In controlled components, the parent component is responsible for managing the state and passing it down as props to the controlled component. This makes it easy to track the state of the component and predict how it will behave. However, in larger projects with many levels of nested components, this can make the code more complex and harder to manage.Besides: 1.It does not maintain its internal state.2.Here, data is controlled by the parent component.3.It accepts its current value as a prop.4.It allows validation control.5.It has better control over the form elements and data. On the other hand, uncontrolled components manage their own state using a ref to access the DOM element's current value and update the state accordingly. This makes them simpler to implement, but they can be more difficult to track and manage in larger projects.1.It maintains its internal states.2.Here, data is controlled by the DOM itself.3.It uses a ref for their current values.4.It does not allow validation control.5.It has limited control over the form elements and data."

    },
    {
        "id":2,
        "question":"2. How to validate React props using PropTypes ?",
        "ans":"PropTypes are simply a mechanism that ensures that the passed value is of the correct datatype. This makes sure that we don’t receive an error at the very end of our app by the console which might not be easy to deal with.Before the release of React 15.5.0, PropTypes were available in the React package, but now we have to add the prop-types library in our project.We can use PropTypes to validate any data we are receiving from props. But before using it we will have to import it as always in our app.Here are some key details about using PropTypes:1.PropTypes is a package that needs to be imported into your component file.2.You can use PropTypes to specify the expected data type of a prop, such as a string, number, or boolean.3.If a prop does not match the specified type or is not present when it's required, a warning will be logged in the console.Here is a list of commonly used PropTypes:'array': for validating an array value.'bool': for validating a boolean value.func: for validating a function value.'number': for validating a number value.'object': for validating an object value.'string': for validating a string value.'symbol': for validating a symbol value.'any': for validating any data type.'element': for validating a React element.'node': for validating a React node.'arrayOf': for validating an array of a specific data type. 'objectOf': for validating an object with values of a specific data type.'shape': for validating an object with specific keys and value types.'oneOf': for validating that the value is one of a specific set of values.'oneOfType': for validating that the value matches one of a specific set of types.  'instanceOf': for validating that the value is an instance of a specific class. 'isRequired': for marking a prop as required and generating a warning if it is not provided."

    },
    {
        "id":3,
        "question":"3. Tell us the difference between nodejs and express js.",
        "ans":"To know the difference between ExpressJS vs NodeJS, we must first analyze each separately. NodeJS is open-source, cross-platform JavaScript code that runs on servers. It uses an asynchronous event-driven model and is designed to build scalable network applications. It’s built on Google Chrome’s V8 engine, which makes it fast and efficient to develop apps.As a server-side technology for modern web applications, NodeJS works well with single-page applications.NodeJS allows developers to take advantage of HTTP requests to stream data from the client to the server and vice versa, without having to buffer the information in the memory beforehand, making it a perfect fit for media streaming platforms.Many big companies use NodeJS in building their applications. Some of them are explored below.Netflix,GoDaddy,PayPal..On the other hand:ExpressJS is a web application framework for NodeJS. That’s what mainly makes the difference between Express JS and Node JS.ExpressJS has been built to support the building of REST APIs, which are one of the most common ways for servers to exchange data with clients.ExpressJS can be used to build real-time services such as chat applications. It supports WebSockets, which allow you to stream data from your server to your client in real-time using persistent connections.Express JS is well-embraced in the development space for building various types of apps. We explore some of them below.MySpace,Yummly etc"

    },
    {
        "id":4,
        "question":"4. What is a custom hook, and why will you create a custom hook?",
        "ans":"Hooks are reusable functions.When you have component logic that needs to be used by multiple components, we can extract that logic to a custom Hook.Custom Hooks start with 'use'.The general rules of React Hooks also apply to custom Hooks; these include:Only call Hooks at the top level. Don’t call Hooks inside loops, conditions, or nested functions.Only call Hooks from React function components.Don’t call Hooks from regular JavaScript functions.With custom React Hooks, we can reuse stateful logic easily across different components in an optimized and scalable format. Custom Hooks also produce a clean and structured codebase that reduces complexity and redundancy in your React project.There is no limit to the types of custom Hooks that you can create for handling different use cases, as long as they follow the rules of React Hooks.Creating a custom hook can be useful in several scenarios:1.Reusability: If you find yourself writing the same code repeatedly across different components, it may be a good idea to extract that code into a custom hook. This way, you can reuse the same logic across your codebase without duplicating it.2.Abstraction: Custom hooks can abstract complex logic and provide a simpler interface for other developers to use. This can make your codebase easier to understand and maintain.3.State management: Custom hooks can be used to manage state and provide a consistent interface for accessing and updating that state.4.Testing: Custom hooks can be easily tested in isolation, making it easier to identify and fix bugs."

    }
]